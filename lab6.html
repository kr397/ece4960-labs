<!DOCTYPE html>
<html lang="en">
    <head>
 
        <title>ECE 4960 Lab 6 - Krithik Ranjan</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
        <link rel="stylesheet" type="text/css" href="main.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@200;300;400;600;700;800&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

        <link href="https://fonts.googleapis.com/css2?family=Major+Mono+Display&display=swap" rel="stylesheet">

        <link href="prism.css" rel="stylesheet" />

        <!--
        <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
        <link rel="icon" href="favicon.ico" type="image/x-icon">
        -->

    </head>
    <body>
        <!--
        <nav class="navbar navbar-expand-md">
            
            <a class="navbar-brand">ECE 4960</a>
            <button class="navbar-toggler navbar-dark" type="button" data-toggle="collapse" data-target="#main-navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            
            <div class="collapse navbar-collapse" id="main-navigation">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">COURSE WEBSITE</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">CODE REPO</a>
                    </li>
                </ul>
            </div>
        </nav>
        -->

        <div class="container-fluid projects">
            <div class="row align-items-center">
                <div class="col-lg-12 col-md-12 col-sm-12">
                    <h2 class="section-title">LAB 6<br>Closed-Loop Control (PID)</h2>
                    <p class="section-text">In this lab, we programmed the robot to perform a stunt with the help of closed-loop control. This was an exciting lab because it was the first software-focused lab of this course where we programmed the Proportional, Integral, Derivative (PID) controller. Lab 6 is the first part in the series of labs 6-8, where we used controllers and sensor fusion to finally perform complete stunts on the robot. </p>
                    <p class="section-text">This lab involved getting a basic behavior working for our choice of one of the three given tasks. I chose to perform Task B in which the robot goes forward, turns and drifts around to a complete 180° flip, and moves straight back. I collaborated on this lab with Aryaa Pai (avp34) and Aparajito Saha (as2537) to discuss implementation and debugging.</p>

                    <h4 class="section-header">Prelab</h4>
                    <p class="section-text">In order to help with the tuning of PID and debugging during the lab, we needed to complete a prelab to set up a codebase for the Artemis side and the python side. This involved integrating various code elements from previous labs, like Bluetooth, IMU, motor PWM. </p>
                    <p class="section-text">I adopted the Bluetooth framework directly from Lab 2 with the necessary modifications for this lab’s use case. This meant that on the computer side, I have a simple Jupyter notebook with different cells to connect to the Artemis and send different commands. On the Artemis, a command handler was called whenever a new command was received with <code class=”inline-code”>RX_STRING</code> characteristic, and the commands were handled through a switch-case construct. For this lab, however, I replaced all the Bluetooth commands to perform different actions and also added some to assist with tuning and debugging. The code snippets below show all the commands added and the implementation in Jupyter notebook and Artemis.</p>

                    <pre><code class="language-ino">// lab6.ino
// Segment of code from bluetooth command handler on Artemis 

void handle_command() {   
    // Set the command string from the characteristic value
    robot_cmd.set_cmd_string(rx_characteristic_string.value(),
                                rx_characteristic_string.valueLength());

    bool success;
    int cmd_type = -1;

    success = robot_cmd.get_command_type(cmd_type);

    // Check if the last tokenization was successful and return if failed
    if (!success) {
        return;
    }

    // Handle the command type accordingly
    switch (cmd_type) {
        /*
            * Stop the motor 
            */
        case STOP:
            Serial.println("[COMMAND] Stop");

            robot.fast_stop();
            break;

        /*
            * Move the robot forward for given number of milliseconds
            */
        case MOVE_FORWARD:
            int spd_; 

            // Extract the next value from the command string as an integer
            success = robot_cmd.get_next_value(spd_);
            if (!success)
                return;

            Serial.print("[COMMAND] Move forward by: ");
            Serial.println(spd_);

            // Move the robot for given seconds
            robot.move_forward(spd_);
            delay(1000);
            robot.slow_stop();

            break;
            
// ...
// More cases for different commands</code></pre>

                    <pre><code class="language-python">// cmd_types.py
// Bluetooth command types 

class CMD(Enum):
    STOP = 0            # ble.send_command(CMD.STOP, "") -- Stops the robot
    MOVE_FORWARD = 1    # ble.send_command(CMD.MOVE_FORWARD, "100") -- Move forward for 1s with speed 100 
    MOVE_BACKWARD = 2   # ble.send_command(CMD.MOVE_BACKWARD, "100") -- Move backward for 1s with speed 100 
    TURN_RIGHT = 3      # ble.send_command(CMD.TURN_RIGHT, "150") -- Turn right for 1s with speed 150 
    TURN_LEFT = 4       # ble.send_command(CMD.TURN_LEFT, "150") -- Turn left for 1s with speed 150
    PERFORM = 5         # ble.send_command(CMD.PERFORM, "") -- Perform task B
    GET_DATA = 6        # ble.send_command(CMD.GET_DATA, "0") -- Get data from Artemis, 0/1 specify which data
    PID_GAINS = 7       # ble.send_command(CMD.PID_GAINS, "0.1|0.0|1.0") -- Set PID gains kp, ki, kd
    SET_SPEEDS = 8      # ble.send_command(CMD.SET_SPEEDS, "120|160") -- Set minimum and maximum speed for the robot
    SET_POINT = 9       # ble.send_command(CMD.SET_POINT, "180.0") -- Setpoint for PID</code></pre>

                    <figure><img src="images/lab5/circuit.png" width="60%"><figcaption>Figure: Circuit diagram with Artemis and motor drivers.</figcaption></figure>

                    <p class="section-text">To control the motors on the robot with varying PWM for different speeds, I created a handler class <code class=”inline-code”>RobotControl</code> shown below. This consisted of all the necessary information about the hardware connections and contained functions to move the robot forward/backward, right/left, and stop with a given speed. </p>

                    <pre><code class="language-ino">// Code for outputting PWM from the Artemis to control the motor driver to run in one direction

int motorA_in1 = 11;
int motorA_in2 = 12;

void setup() {
    pinMode(motorA_in1, OUTPUT);
    pinMode(motorA_in2, OUTPUT);
}

void loop() {
    int curr_speed = 100;

    analogWrite(motorA_in1, curr_speed);
    analogWrite(motorA_in2, 0);
}</code></pre><br>

                    <p class="section-text">Similarly, to interact with the IMU sensor using I2C, I created a <code class=”inline-code”>IMU</code> class to encapsulate the setup of the sensor and obtain its readings to measure the yaw angle (for task B). I used the gyroscope integral method to calculate the yaw and found it to have a linear error in the observed angles, which I fixed with a two-point calibration method. </p>

                    <p class="section-text"> Finally, I also created a static array data structure to efficiently store any data (yaw, error, speeds, etc.) and send it to the computer later for logging. </p>

                    <h4 class="section-header">PID</h4>
                    <p class="section-text">The PID controller is a common closed-loop control system used in robotics. PID provides the required output to reach a specified setpoint, based on the feedback obtained using a sensor to calculate the error. In the case of task B, the output of the system would be the PWM duty cycle with which the robot turns, while the setpoint and the feedback would be of the yaw angle measured using the gyroscope in the IMU. </p>
                    <p class="section-text">As the name suggests, PID includes proportional, integral, and derivative terms of the measured error, determined by constants <code class=”inline-code”>kp, ki, kd</code>. The sum of these terms produces the next output speed of the motors. Determined experimentally, the robot has a deadband speed below which it doesn’t move on the ground (which changes as the batteries get depleted). For this lab, we also want the robot to move slowly to ensure stability and thus put an upper limit on the speed from the controller. The final motor speed from these limits and the PID output to also account for turning in different directions has been shown below. </p>


                    <figure><img src="images/lab5/robot.jpg" width="60%"><figcaption>Figure: Assembled circuit on the robot</figcaption></figure>
                    
                    <p class="section-text">I started implementing PID on the robot with the P term. With a low value of proportional constant (below 0.1), I found that while the robot turned, it stops at an angle significantly below the target. This steady-state error is expected because the robot with a low P term is unable to overcome the deadband speed. At a high constant, we see that the robot turns and overshoots the target angle, only to turn back and eventually start oscillating around the target with a low amplitude. </p>

                    <p class="section-text">After getting a suitable range of constants for the P term, I added the derivative term. As expected, the D term reduced the speed of the robot even quicker as it approached the target angle, thus reducing the overshoot. Even without a low-pass filter, the derivative gave stable enough values to be added to the controller. </p>

                    <p class="section-text"> After carefully selecting the proportional and derivative gains, I was able to produce the desired response of task B. I tried to also add the integral term, but I was unable to properly account for the extremely high accumulation of the error sum leading to a high output speed. For the complete sequence, I implemented a timed forward movement, followed by the 180° turn and another timed forward movement. In order to detect that the robot had reached its desired angle, I counted its oscillations through the change of sign of error. </p>

                    <h4 class="section-header">Demonstration and Results</h4>
                    <p class="section-text">The videos included below show the three trials performed on the robot with the discussed implementation of PID control. The robot seems to be performing the task very well in all the three cases, where it moves forward, turns around quickly, and comes back almost to the same spot. After each video, a plot shows the measured gyroscope angle as the robot moves, and we can see how the angle is stable in the beginning (during the forward motion), then changes to the setpoint while turning, and quickly stabilizes to the new angle while coming back. The PID control parameters and other variables were set to the values shown below.  </p>

                    <pre><code class="language-ino">void loop() {
    int curr_speed = 100;
    // Delayed start to allow time for placing the robot
    delay(5000);

    // Run forward for 2 seconds
    motor_fwd(motorA_in1, motorA_in2, curr_speed);
    motor_fwd(motorB_in1, motorB_in2, curr_speed);

    delay(2000);

    motor_stop(motorA_in1, motorA_in2);
    motor_stop(motorB_in1, motorB_in2);

    // Busy wait 
    while (1);
}

void motor_fwd(int in1, int in2, int spd)
{
    analogWrite(in1, spd);
    analogWrite(in2, 0);
}

void motor_back(int in1, int in2, int spd)
{
    analogWrite(in1, 0);
    analogWrite(in2, spd);
}

void motor_stop(int in1, int in2)
{
    analogWrite(in1, 0);
    analogWrite(in2, 0);
}</code></pre>

                    <figure><iframe width="560" height="315" src="https://www.youtube.com/embed/_Z1bJNBrB6s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure>

                    <p class="section-text">While tuning the controller and conducting multiple trials, I found that in order to achieve a complete 180° flip, the setpoint  needs to be around 150°. This offset consistently provided the expected result, so I conducted the final trials this offset setpoint. Another observation is that even though the robot turns around completely, it doesn’t retrace its path back to the starting position and instead follows a parallel path to the right. This could be because the robot is not turning on the spot but instead taking a bigger turn radius. I suspect that this can be fixed by calibrating the two motors while turning such that they move with the exact same speed, and I plan to test and fix this before Lab 8. </p>

                    <pre><code class="language-ino">void loop() {
    int curr_speed = 100;
    delay(5000);

    // Move forward
    motor_fwd(motorA_in1, motorA_in2, curr_speed);
    motor_fwd(motorB_in1, motorB_in2, curr_speed);

    delay(1000);

    motor_stop(motorA_in1, motorA_in2);
    motor_stop(motorB_in1, motorB_in2);

    delay(500);
    
    // Turn left
    motor_fwd(motorA_in1, motorA_in2, curr_speed);
    motor_back(motorB_in1, motorB_in2, curr_speed);

    delay(1000);

    // Move forward
    motor_fwd(motorA_in1, motorA_in2, curr_speed);
    motor_fwd(motorB_in1, motorB_in2, curr_speed);

    delay(1000);

    motor_stop(motorA_in1, motorA_in2);
    motor_stop(motorB_in1, motorB_in2);

    delay(500);

    // Turn left 
    motor_fwd(motorA_in1, motorA_in2, curr_speed);
    motor_back(motorB_in1, motorB_in2, curr_speed);

    delay(1000);

    // Move forward
    motor_fwd(motorA_in1, motorA_in2, curr_speed);
    motor_fwd(motorB_in1, motorB_in2, curr_speed);

    delay(1000);

    motor_stop(motorA_in1, motorA_in2);
    motor_stop(motorB_in1, motorB_in2);

    // Busy wait 
    while (1);
}</code></pre>

                <figure><iframe width="560" height="315" src="https://www.youtube.com/embed/3KJ41SoyTX8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure>

                    
                </div>
            </div>
        
        </div>

        <footer class="footer mt-auto py-3">
            <div class="container">
                <h5><a href="index.html">< home</a> | <a href="https://github.com/kr397/ece4960-labs/tree/main/Lab2">code ></a></h5>
                <p><a href="mailto:kr397@cornell.edu">KR397[AT]CORNELL[DOT]EDU</a></p>
            </div>
        </footer>  
        
        <script src="prism.js"></script>
		<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" integrity="sha384-w1Q4orYjBQndcko6MimVbzY0tgp4pWB4lZ7lr30WKz0vr/aWKhXdBNmNb5D92v7s" crossorigin="anonymous"></script>
    </body>
    
</html>
