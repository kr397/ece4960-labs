<!DOCTYPE html>
<html lang="en">
    <head>
 
        <title>ECE 4960 Lab 11 - Krithik Ranjan</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
        <link rel="stylesheet" type="text/css" href="main.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@200;300;400;600;700;800&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

        <link href="https://fonts.googleapis.com/css2?family=Major+Mono+Display&display=swap" rel="stylesheet">

        <link href="prism.css" rel="stylesheet" />

        <!--
        <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
        <link rel="icon" href="favicon.ico" type="image/x-icon">
        -->

    </head>
    <body>
        <!--
        <nav class="navbar navbar-expand-md">
            
            <a class="navbar-brand">ECE 4960</a>
            <button class="navbar-toggler navbar-dark" type="button" data-toggle="collapse" data-target="#main-navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            
            <div class="collapse navbar-collapse" id="main-navigation">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">COURSE WEBSITE</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">CODE REPO</a>
                    </li>
                </ul>
            </div>
        </nav>
        -->

        <div class="container-fluid projects">
            <div class="row align-items-center">
                <div class="col-lg-12 col-md-12 col-sm-12">
                    <h2 class="section-title">LAB 11<br>Localization (Simulator)</h2>
                    <p class="section-text">Lab 11 was the first localization lab, which is a focus of the last part of the course. In this lab, we implemented grid localization on a virtual robot in the simulator using the Bayes Filter, while the robot follows a preprogrammed trajectory in grid. This lab helped me learn a lot about using a simulator and about the Bayes filter, which I didn't have any experience with before. The codebase equipped with the simulator, mapper and other things, along with all the information provided in the lab handout and the skeleton Jupyter notebook was extremely helpful in completing this lab, as it reduced our task to simply understanding and implementing the Bayes filter. </p>

                    <h4 class="section-header">Background</h4>
                    <p class="section-text">The Bayes Filter, as discussed in class, provides a probabilistic Robot-Environment model based on the belief distribution of the robot calculated with the help of measurements and control data. The filter can be broken down in two main steps, the prediction and the update, which are shown below with the Bayes filter algorithm. In the prediction step, the robot takes its prior belief about its location in the grid, and predicts is current location based on the movement that it went through (motion model). To update its belief, the robot takes a sensor measurement and compares that with the previously taken sensor measurement from every state in the grid to find the likelihood of it being in each state.</p>
                    <figure>
                        <img src="images/lab11/bayes_algorithm.png" width="80%">
                        <figcaption>Figure: Bayes Filter algorithm (adapted from Lecture 17 slides)</figcaption>
                    </figure>

                    <p class="section-text">The robot state is 3-dimensional and defined by <code class="inline-code">(x, y, angle)</code> which have the following ranges in the state space.</p>
                    <pre><code class="language-">- x: [-1.6764, +1.9812) meters or [-5.5, 6.5) feet
- y: [-1.6764, +1.9812) meters or [-5.5, 6.5) feet
- angle: [-180°, 180°]</code></pre>
                    <p>In order to practically implement the Bayes filter, we need to discretize the robot state space into grid cells. For these labs, we do so for x and y with the help of 1ft tile markers in the room, and for angles, by splitting into 18 20°-increments, resulting in a discrete grid space of the size <code class="inline-code">(12, 9, 18)</code></p>


                    <h4 class="section-header">Prediction Step</h4>
                    <p class="section-text">For the prediction step, we need to first define the robot motion model. In this lab and the next, the motion model of the robot is described as a Gaussian distribution centered at the motion measured using odometry of the robot. The motion control of the robot is described as a tuple of <code class="inline-code">(rotation_1, translation, rotation_2)</code> which was discussed in Lecture 18. We define a function <code class="inline-code">compute_control()</code> to find this motion control from the previous and current odometry poses.</p>
                    <figure>
                        <img src="images/lab11/motion_model.png" width="60%">
                        <figcaption>Figure: Motion control of the robot</figcaption>
                    </figure>
                    <pre><code class="language-python">def compute_control(cur_pose, prev_pose):
    """ Given the current and previous odometry poses, this function extracts
    the control information based on the odometry motion model.

    Args:
        cur_pose  ([Pose]): Current Pose
        prev_pose ([Pose]): Previous Pose 

    Returns:
        [delta_rot_1]: Rotation 1  (degrees)
        [delta_trans]: Translation (meters)
        [delta_rot_2]: Rotation 2  (degrees)
    """

    # Calculate the direction of cur_pose from prev_pose 
    dir_trans = degrees(atan2(cur_pose[1] - prev_pose[1], cur_pose[0] - prev_pose[0]))

    # First rotation
    delta_rot_1 = mapper.normalize_angle(dir_trans - prev_pose[2])

    # Translation distance 
    delta_trans = sqrt((cur_pose[1] - prev_pose[1])**2 + (cur_pose[0] - prev_pose[0])**2)

    # Second rotation
    delta_rot_2 = mapper.normalize_angle(cur_pose[2] - dir_trans)

    return delta_rot_1, delta_trans, delta_rot_2</code></pre>
                    <p class="section-text">The <code class="inline-code">odom_motion_model()</code> function calculates the likelihood of movement from one pose to another given a control <code class="inline-code">p(x'|x, u)</code>, based ont the Gaussian distribution of each of the control variables using joint probability of the independent variables.</p>
                    <pre><code class="language-python">def odom_motion_model(cur_pose, prev_pose, u):
    """ Odometry Motion Model

    Args:
        cur_pose  ([Pose]): Current Pose
        prev_pose ([Pose]): Previous Pose
        (rot1, trans, rot2) (float, float, float): A tuple with control data in the format 
                                format (rot1, trans, rot2) with units (degrees, meters, degrees)

    Returns:
        prob [float]: Probability p(x'|x, u)
    """
    # Find the control for the given pair of poses 
    u_calc = compute_control(cur_pose, prev_pose)
    
    # Calculate probabilities of different control motions as a gaussian distribution centered 
    # at the input control u
    prob_rot_1 = loc.gaussian(u_calc[0], u[0], loc.odom_rot_sigma)
    prob_trans = loc.gaussian(u_calc[1], u[1], loc.odom_trans_sigma)
    prob_rot_2 = loc.gaussian(u_calc[2], u[2], loc.odom_rot_sigma)
    
    # Calculate total probability 
    prob = prob_rot_1 * prob_trans * prob_rot_2

    return prob</code></pre>
                    <p class="section-text">In the prediction step, we calculate <code class="inline-code">bel_bar</code> for every cell in the grid space which is the predicted belief of the robot in each cell based on its prior belief and its movement. Therefore, we iterate over each cell and its belief (previous), find the likelihood of reaching every cell from it after the odometry-described motion (current) and add all of those up to find the predicted belief distribution. Finally, we can normalize the predicted belief <code class="inline-code">bel_bar</code>. As shown in the code snippet of <code class="inline-code">prediction_step()</code>, this results in a nested 6 for-loop structure to computer over every grid cell pair, which can take a huge amount of computation time. To reduce the execution time, I introduced an optimization where the inner current cell nested-loop is only executed if the belief in the previous cell is above the threshold of 0.0005. I determined this threshold as a large value less than the initial belief of 0.0005144 (computed with uniform distribution), which is important in order to not zero-out the distribution. While this change led to reasonable computation time with the simulator, there can be further optimizations which I will experiment with and include while implementing the Bayes filter on the robot.</p>

                    <pre><code class="language-python">def prediction_step(cur_odom, prev_odom):
    """ Prediction step of the Bayes Filter.
    Update the probabilities in loc.bel_bar based on loc.bel from the previous time step and the 
    odometry motion model.

    Args:
        cur_odom  ([Pose]): Current Pose
        prev_odom ([Pose]): Previous Pose
    """
    # Initialize bel_bar as zeros 
    loc.bel_bar = np.zeros((mapper.MAX_CELLS_X, mapper.MAX_CELLS_Y, mapper.MAX_CELLS_A))
    
    # Find actual control based on odometry 
    u_act = compute_control(cur_odom, prev_odom)
    
    # Iterate over the belief of each cell as the prev pose 
    for cx1 in range(mapper.MAX_CELLS_X):
        for cy1 in range(mapper.MAX_CELLS_Y):
            for ca1 in range(mapper.MAX_CELLS_A):
                
                # Only move forward with cells who have a significant belief (> 0.0005)
                if loc.bel[cx1][cy1][ca1] > 0.0005:
                
                    # Sum motion model probability over every cell as the curr pose after u_act 
                    for cx2 in range(mapper.MAX_CELLS_X):
                        for cy2 in range(mapper.MAX_CELLS_Y):
                            for ca2 in range(mapper.MAX_CELLS_A):
                                # Prob of robot moving from (cx1, cy1, ca1) to (cx2, cy2, ca2) 
                                odom_model = odom_motion_model(mapper.from_map(cx2, cy2, ca2), \ 
                                    mapper.from_map(cx1, cy1, ca1), u_act)

                                # Add prob to bel_bar of this cell based on belief in prev cell
                                loc.bel_bar[cx2][cy2][ca2] = loc.bel_bar[cx2][cy2][ca2] + \ 
                                    (odom_model * loc.bel[cx1][cy1][ca1])</code></pre><br>

                    <h4 class="section-header">Update Step</h4>
                    <p class="section-text">Once we have the predicted belief for every grid cell based on the motion model, we can verify it using sensor measurements. The sensor model is also described as Gaussian distribution using the Beam model for sensors. We only account for the correct range measurements to simplify the model. At every time step, the robot rotates in-place to collect 18 sensor readings placed at 20° angle increments to cover the range [-180°, 180°), which are then compared with the precached sensor measurements from each cell in the grid to update the belief of that cell. The <code class="inline-code">sensor_model()</code> computes the similarity of the current sensor measurement along each of the 18 angle increments with a given set of observations, computed using a Gaussian variable as <code class="inline-code">p(z|x)</code>.</p>

                    <pre><code class="language-python">def sensor_model(obs):
    """ This is the equivalent of p(z|x).

    Args:
        obs ([ndarray]): A 1D array consisting of the true observations for a specific robot pose 
            in the map 

    Returns:
        [ndarray]: Returns a 1D array of size 18 (=loc.OBS_PER_CELL) with the likelihoods of each 
            individual sensor measurement
    """
    # Initialize array 
    prob_array = np.zeros(mapper.OBS_PER_CELL)
    
    # For a given pose, the probability of the obtained sensor measurement based on true observations 
    for i in range(mapper.OBS_PER_CELL):
        prob_array[i] = loc.gaussian(loc.obs_range_data[i], obs[i], loc.sensor_sigma)

    return prob_array</code></pre>

                    <p class="section-text">In order to update the belief in each grid cell, we use this sensor model along with the predicted belief of that cell. The <code class="inline-code">update_step()</code> function iterates over all the grid cells to perform this computation in which the sensor model is computed as a joint probability over the 18 sensor measurements by comparing the precached sensor data for that cell and the latest sensor measurements, which is then multiplied by the <code class="inline-code">bel_bar</code> of that cell from the prediction step. Finally, the belief distribution is normalized to make it an appropriate probability distribution.</p>

                    <pre><code class="language-python">def update_step():
    """ Update step of the Bayes Filter.
    Update the probabilities in loc.bel based on loc.bel_bar and the sensor model.
    """
    # Iterate over each cell to update its belief
    for cx in range(mapper.MAX_CELLS_X):
        for cy in range(mapper.MAX_CELLS_Y):
            for ca in range(mapper.MAX_CELLS_A):
                # The sensor model at this cell and probability of being same as observations
                sens_model = np.prod(sensor_model(mapper.get_views(cx, cy, ca)))
                
                # Update belief based on sensor model and bel_bar 
                loc.bel[cx][cy][ca] = sens_model * loc.bel_bar[cx][cy][ca]
    
    # Normalized the belief distribution 
    loc.bel = loc.bel / np.sum(loc.bel)</code></pre><br>

                <h4 class="section-header">Results</h4>
                <p class="section-text">After implementing all the necessary functions for the Bayes filter, we tested it over the trajectory provided in the codebase. The trajectory moves the robot over a set of control motions, and performs the Bayes prediction and update after each step to localize in the grid. The interface also simultaneously plots the actual movement of the robot, its the result of its localization (belief), and also the location of the robot calculated using odometry. From the plots of the four trials shown below, we can see that the results of the localization are mostly appropriate, with the robot's belief being fairly close to its actual location.</p> 

                <figure>
                    <img src="images/lab11/run1.png" width="45%">
                    <img src="images/lab11/run2.png" width="45%">
                </figure>
                <figure>
                    <img src="images/lab11/run3.png" width="45%">
                    <img src="images/lab11/run4.png" width="45%">
                    <figcaption>Figure: 4 trials of Bayes filter localization on the simulator with three trajectories: ground truth (green), robot's belief (blue), and odometry-based (red)</figcaption>
                </figure>

                <p class="section-text">Even in the statistics for one of the trials we can see small amount of error and the robot's high confidence in its belief (almost always close to 1) which means that the localization is working well. A notable thing is that the <code class="inline-code">POS ERROR</code> for the angle was piling up to a large value. This is because the ground truth update in the angle is not normalized, and keeps getting increased after each run. After several trials, I found that the localization during a straight path in the trajectory is better than that in the corners, for example the top right and the bottom left corner in the trajectory. I wonder if the cause for this is ambiguity in the robots sensor measurement and the sensor model. </p>

                <figure>
                    <img src="images/lab11/stats1.png" width="60%">
                    <img src="images/lab11/stats2.png" width="60%">
                    <figcaption>Figure: Statistics log of one trial run on the virtual robot as it moves through the trajectory and localizes using Bayes filter at every step.</figcaption>
                </figure>

                <p class="section-text">A useful feature to add to this codebase would be a way to visualize the <code class="inline-code">bel</code> and <code class="inline-code">bel_bar</code> probability distributions, similar to those shown in the lectures. For this lab, I was planning to add a 3D heatmap to do so, such that instead of only the highest belief index, we can see the robots belief across all the cells. This would help us monitor the change in robot belief, and also potentially determine the reason behind some of the discrepancies. While I was short on time to do this for lab 11, I plan to implement it in lab 12 for debugging purposes. </p>

                <p class="section-text">Overall, this was a more challenging lab than the previous few in terms of coding, however, not having to run and debug code on the robot was refreshing. I look forward to get back to it in the next lab as we implement the Bayes filter on the robot and try to localize.</p>

                <!--
                    <figure><iframe width="560" height="315" src="https://www.youtube.com/embed/P6zWHMy9_Xg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                    </figure>
                -->
 
                </div>
            </div>
        
        </div>

        <footer class="footer mt-auto py-3">
            <div class="container">
                <h5><a href="index.html">< home</a> | <a href="https://cei-lab.github.io/ECE4960-2022/Lab11.html">handout ></a></h5>
                <p><a href="mailto:kr397@cornell.edu">KR397[AT]CORNELL[DOT]EDU</a></p>
            </div>
        </footer>  
        
        <script src="prism.js"></script>
		<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" integrity="sha384-w1Q4orYjBQndcko6MimVbzY0tgp4pWB4lZ7lr30WKz0vr/aWKhXdBNmNb5D92v7s" crossorigin="anonymous"></script>
    </body>
    
</html>
