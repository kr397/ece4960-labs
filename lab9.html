<!DOCTYPE html>
<html lang="en">
    <head>
 
        <title>ECE 4960 Lab 9 - Krithik Ranjan</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
        <link rel="stylesheet" type="text/css" href="main.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@200;300;400;600;700;800&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

        <link href="https://fonts.googleapis.com/css2?family=Major+Mono+Display&display=swap" rel="stylesheet">

        <link href="prism.css" rel="stylesheet" />

        <!--
        <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
        <link rel="icon" href="favicon.ico" type="image/x-icon">
        -->

    </head>
    <body>
        <!--
        <nav class="navbar navbar-expand-md">
            
            <a class="navbar-brand">ECE 4960</a>
            <button class="navbar-toggler navbar-dark" type="button" data-toggle="collapse" data-target="#main-navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            
            <div class="collapse navbar-collapse" id="main-navigation">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">COURSE WEBSITE</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">CODE REPO</a>
                    </li>
                </ul>
            </div>
        </nav>
        -->

        <div class="container-fluid projects">
            <div class="row align-items-center">
                <div class="col-lg-12 col-md-12 col-sm-12">
                    <h2 class="section-title">LAB 9<br>Mapping</h2>
                    <p class="section-text">Lab 9 is the first lab in the second half of the course with a focus on mapping and localization. In this lab, we use our robot to build a map of a room or arena set up in the lab space with information about the boundaries and the objects placed within. This was a very interesting lab and a new experience for me in robotics. It was super helpful that the course staff set everything up early and made sure that we utilize the time before spring break to get all the data points.</p>

                    <p class="section-text">In the setup of the room, there are a few marked locations on which the robot needs to be placed and rotated, to get a series of distance measurements using the TOF sensor in the front of the robot. I chose to use my PID controller from Lab 6 to move the robot by fixed angle increments and take measurements. I worked on this lab with Aparajito Saha (as2537) and Aryaa Pai (avp34) for the data collection and manipulation.</p>

                    <h4 class="section-header">PID Orientation Control</h4>
                    <p class="section-text">In Lab 6, I performed task B which involved turning the robot around by 180° using PID (I implemented PD). For this lab, I modified that code to do orientation control such that the robot turns over small angular increments, and takes a TOF distance measurement after each step. This was coded as a new Bluetooth command sent from the Jupyter notebook. </p>

                    <p class="section-text">Ideally, the PID controller should turn the robot to reach the exact specified set angle. However, due to noise in IMU angular velocity measurement, I found that my controller had a constant linear offset in the angle, as I mentioned in Lab 6. Due to this, the robot turns 180° with a set point of 155° or 20° with a set point of 17°. After several runs with the same observation, I used this as a configuration and ran the control with the corrected set point. The robot turning from 0° to 360° over 20° increments can be seen in the video below. </p>

                    <figure><iframe width="560" height="315" src="https://www.youtube.com/embed/hBQLcoQyHa8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure>

                    <p class="section-text">As seen in the video, the robot doesn’t perfectly rotate on its axis, but instead the center of the robot drifts by a couple of centimeters from the marker, which may introduce error in the distance measurement. If the robot were placed in the middle of a 4x4m empty square, the displacement during the rotation will introduce up to 4-5 cm error for measurements on one side of the room (+180° from the starting orientation). We have also found the TOF to not be completely accurate, and it may further introduce an error of a few centimeters. </p>

                    <p class="section-text">In order to deal with these potential errors, one solution could be to take more data points. Since the PID control on my robot was reliable for small angles, I turned the robot by 10° increments to get at least 36 data points from each marker, which worked better than 20° as discussed in the next section. One thing to note is that my PID controller turns the robot to its right, and therefore in the clockwise direction. Moreover, the starting angle for every mapping sweep was 180°, as seen in the video. Thus, the 36 angle increments were [170°, 160°, 150°, …, -160°, -170°, -180°]. </p>

                    <h4 class="section-header">Distance Measurement</h4>
                    <p class="section-text">Once the robot was able to spin properly over a set of increments, I added a distance measurement function after every turn. The robot was then kept to map distances from the 5 markers placed in the room at (0, 0), (-3, -2), (0, 3), (5, 3), (5, -3), and send the distance arrays to the Jupyter notebook over Bluetooth. The TOF sensor was placed in front of the robot and configured in the long-distance ranging mode like in the previous labs. </p>

                    <p class="section-text">Since my gyroscope measurements were a little skewed, I didn’t use the measured yaw after every turn to associate with the distance measurement at that point to create the (R, ϴ) pairing. Instead, I equally divided up the 360° angle space into 36 angles at 10° increments and mapped the 36 distance values to the presumed angle space of  [170°, 160°, 150°, …, -160°, -170°, -180°]. The small-angle increments and the greater number of measurements ensured that this hack didn’t introduce any significant error. </p>

                    <p class="section-text">We first performed the mapping sweep with the robot from one marker point multiple times, to make sure that the movement and the distance measurement were reliable. Thereafter, we did the mapping from all 5 markers. The results from marker (0, 3) are shown below. </p>

                    <figure>
                        <img src="images/lab9/distance_0_3.png" width="50%">
                        <img src="images/lab9/polar_0_3.png" width="30%">
                        
                        <figcaption>Figure: Distance measurement taken from (0, 3) at different angles as a line plot (left) and polar plot (right).</figcaption>
                    </figure>

                    <h4 class="section-header">Creating the Map</h4>
                    <p class="section-text">After obtaining the distance mapping of the room from each of the markers, we needed to merge all the data to create a more complete map of the room. First, we had to convert the polar distance measurement from each marker to the inertial frame of reference in the cartesian form using transformation matrices. We were not too familiar with transformation matrices, so after talking with Vivek, we did a more manual conversion which worked just as well. The conversion algorithm, and its usage for converting and plotting the map from marker (5, 3) are shown below. </p>

                    <pre><code class="language-python"># Conversion of distance at different angles (polar) to cartesian coordinates in the inertial frame 

# Offset of TOF from center of the robot: DIST_TOF
# Location of marker: xo, yo 

for d, theta : (distance, angles):
    d = d + DIST_TOF 

    x = d * cos(theta) + xo 
    y = d * sin(theta) + yo 

    return x, y </code></pre><br>

                    <pre><code class="language-python"># Code to convert and plot the data collected from marker (5, 3)

# Convert marker position to mm
x0 = feet_to_mm(5.0)
y0 = feet_to_mm(3.0)

# Load the data 
distance_5_3 = np.array([...])
angles_5_3   = np.array([...])

# Convert to polar coordinates 
xs_5_3, ys_5_3 = polar_to_cartesian(angles_5_3, distance_5_3)

# Translate readings with the marker 
xs_5_3 = xs_5_3 + x0 
ys_5_3 = ys_5_3 + y0 

# Plot the data points 
plt.grid()
plt.scatter(xs_5_3, ys_5_3)

# Plotting the marker 
plt.scatter(x0, y0, marker='+')
    
plt.show() </code></pre>

                    <figure>
                        <img src="images/lab9/map_5_3.png" width="80%">
                        
                        <figcaption>Figure: Mapping distance points taken from (5, 3).</figcaption>
                    </figure>

                    <p class="section-text">Once this plot was created for each of the markers, we plotted all of them on the same figure along with the actual room grid for reference. As we can see, the mapping procedure generated a somewhat acceptable result with a few inconsistencies. While the boundary of the room seems to be mostly appropriately mapped, there is not a very clear shape of the two boxes placed in the room.</p>

                    <figure>
                        <img src="images/lab9/map_full.png" width="80%">
                        <figcaption>Figure: Full map of the room after merging distance measurements from each marker.</figcaption>
                    </figure>

                    <p class="section-text">From the mapping generated by the robot, we can create the robot’s own perception of the room as a line map. This will slightly vary from the actual map of the room because of the inaccuracies in the distance measurement. However, it will be more suitable to use this robot map in the simulator for future labs, as it better represents the perception of the robot. There can be multiple ways to find the lines of best fit to derive the map from the data points. I considered using linear regression to find the actual lines of best fit for different subsets of the points but abandoned the idea due to time constraints. </p>

                    <p class="section-text">First, I tried determining all the lines in the map by direct observation of the point clusters, giving more priority to points measured from a nearby marker. For example, red points given more priority in the top right corner, while orange ones in the bottom left. This resulted in the map shown below, in which the top and right edges are straight like in the actual map, while all the other edges are distorted. This can be an acceptable map of the room.</p>

                    <figure>
                        <img src="images/lab9/map_drawn.png" width="80%">
                        <img src="images/lab9/map_compare.png" width="80%">
                        <figcaption>Figure: Map created from the distance measurements by the robot at different locations; compared with the actual room map.</figcaption>
                    </figure>

                    <p class="section-text">I also developed another type of mapping with the data, based on the prior knowledge that all the corners in the room are right angles, thus resulting in only vertical and horizontal edges. In order to do this, I selected a cluster of points that represent an edge, and averaged their x/y coordinate to obtain the constant parameter of the edge. For example, in order to compute the position of the right edge, I took all the data points on the right side and averaged their x-coordinate. Similarly, the y coordinate for all horizontal edges. This results in a map that matches very well to the true map of the room, especially at the boundaries of the room. This method also required careful selection of the points to be included in each cluster, while ignoring signicantly inaccurate, or misplaced measurements. Even so, due to the lack of data points around the middle box and the nook at the bottom of the room, the mapping of those areas is noticeably inaccurate.</p>

                    <figure>
                        <img src="images/lab9/map_avg.png" width="80%">
                        <img src="images/lab9/map_avg_compare.png" width="80%">
                        <figcaption>Figure: Map created using the averaging method for each edge; compared with the actual room map</figcaption>
                    </figure>

                    <p class="section-text">This was a really fun lab! I hope that the line maps created of the room using the robot in this lab will work well for the tasks in future labs. </p>
 
                </div>
            </div>
        
        </div>

        <footer class="footer mt-auto py-3">
            <div class="container">
                <h5><a href="index.html">< home</a> | <a href="https://github.com/kr397/ece4960-labs/tree/main/Lab2">code ></a></h5>
                <p><a href="mailto:kr397@cornell.edu">KR397[AT]CORNELL[DOT]EDU</a></p>
            </div>
        </footer>  
        
        <script src="prism.js"></script>
		<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" integrity="sha384-w1Q4orYjBQndcko6MimVbzY0tgp4pWB4lZ7lr30WKz0vr/aWKhXdBNmNb5D92v7s" crossorigin="anonymous"></script>
    </body>
    
</html>
